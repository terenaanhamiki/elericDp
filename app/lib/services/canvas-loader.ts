/**
 * Canvas Loader Service
 * Loads and restores canvas state from Supabase
 */

import { canvasStore } from '~/lib/stores/canvas';
import { screenPersistence } from './screen-persistence';
import { supabasePersistence } from './supabase-persistence';

export class CanvasLoaderService {
  private currentProjectId: string | null = null;

  /**
   * Load canvas for a project
   */
  async loadProjectCanvas(projectId: string, maxScreens: number = 50): Promise<boolean> {
    try {
      console.log(`üìê Loading canvas for project: ${projectId}`);

      // Clear current canvas
      canvasStore.clearAll();

      // Wait for Supabase to be initialized and user context to be set
      const { supabasePersistence } = await import('./supabase-persistence');
      console.log('‚è≥ Waiting for user context to be ready...');
      const isReady = await supabasePersistence.waitForUserContext(5000);
      
      if (!isReady) {
        console.warn('‚ö†Ô∏è User context not ready after 5 seconds, proceeding anyway');
      } else {
        console.log('‚úÖ User context ready, proceeding with screen loading');
      }

      // Load screens from Supabase
      console.log('üîç Querying screens for project:', projectId);
      const screens = await screenPersistence.loadProjectScreens(projectId);
      console.log('üìä Screens query result:', {
        count: screens.length,
        screens: screens.map((s) => ({ id: s.id, name: s.name })),
      });

      if (screens.length === 0) {
        console.log('‚ÑπÔ∏è No screens found for this project - canvas will be empty');
        this.currentProjectId = projectId;
        return true; // Changed to true - project loaded, just no screens yet
      }

      // Limit screens to prevent performance issues
      const screensToLoad = screens.slice(0, maxScreens);
      console.log(`üìÑ Found ${screens.length} screens, loading first ${screensToLoad.length}`);

      // Add each screen to canvas
      let loadedCount = 0;
      for (const screen of screensToLoad) {
        try {
          const pageId = canvasStore.addPage({
            name: screen.name,
            path: `/screens/${screen.id}`,
            html: screen.htmlContent,
            css: screen.cssContent,
            js: screen.jsContent,
            previewUrl: '', // Will be generated by canvas store
            size: { width: 400, height: 500 },
          });

          // Update position if saved
          if (screen.canvasPosition) {
            canvasStore.updatePagePosition(pageId, screen.canvasPosition);
          }

          loadedCount++;
        } catch (error) {
          console.error(`‚ùå Failed to load screen ${screen.name}:`, error);
        }
      }

      // Load canvas state (zoom, active page, etc.)
      console.log('üé® Loading canvas state for project:', projectId);
      const canvasState = await supabasePersistence.getCanvasState(projectId);
      if (canvasState?.activePage) {
        console.log('‚úÖ Restored active page:', canvasState.activePage);
        canvasStore.setActivePage(canvasState.activePage);
      }

      this.currentProjectId = projectId;
      console.log(`‚úÖ Canvas loaded successfully: ${loadedCount} screens restored`);

      return true;
    } catch (error) {
      console.error('Failed to load canvas:', error);
      return false;
    }
  }

  /**
   * Load user's most recent project canvas
   * DISABLED: Canvas should start clean, screens load as they're created
   */
  async loadMostRecentCanvas(): Promise<boolean> {
    console.log('‚ÑπÔ∏è Canvas starts clean - screens will load as created');
    // Don't auto-load any project - keep canvas empty
    return false;
  }

  /**
   * Get current project ID
   */
  getCurrentProjectId(): string | null {
    return this.currentProjectId;
  }

  /**
   * Clear canvas
   */
  clearCanvas(): void {
    canvasStore.clearAll();
    this.currentProjectId = null;
  }
}

export const canvasLoader = new CanvasLoaderService();
